# 数组
## 1.数组理论基础

**数组是存放在连续内存空间上的相同类型数据的集合。**
* **数组下标都是从0开始的。**

* **数组内存空间的地址是连续的**

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**
## 2. 二分查找
使用该方法的前提条件：
* 数组为有序数组。
* 数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

下面我用这两种区间的定义分别讲解两种不同的二分写法。
* **二分法第一种写法**
第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。
区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**
  * while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  * if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

* **二分法第二种写法**
如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。有如下两点：
  * while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
  * if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

常规的二分法left和right指的是数组的index，是离散的，而有时候二分法是在**连续区间**内使用，比如牛客HJ_107 求解立方根。

**leetcode题号**：704，35，34，69，367
**leetcode 34:**
寻找target在数组里的左右边界，有如下三种情况：

* 情况一：target 在数组范围的右边或者左边。
* 情况二：target 在数组范围中，且数组中不存在target。
* 情况三：target 在数组范围中，且数组中存在target。

采用两次二分法，分别寻找左边界和右边界。与常规二分法不同，此题在nums[mid] == target的时候也需要更改左或右边界。最后根据左右边界的情况决定是三种情况的哪一种。



## 3.移除元素 

**双指针法**（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

**leetcode题号**：27，26，283，844，977
**leetcode 844:**
* 方法一：重构字符串:使用栈，push和pop模拟过程
* 方法二：双指针，从后向前遍历，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。

## 4.有序数组的平方

**leetcode 977:**
* 双指针1：利用数组nums已经按照升序排序这个条件。找到正负分界线，用双指针分别向两侧移动，每次把平方较小的那个数加入ans，移动其对应的指针，直到有一个指针移动到边界，而后把另一个指针剩余的位置按顺序加入ans。
* 双指针2：i指向起始位置，j指向终止位置。定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。双指针从两边向中间移动。

## 5.长度最小的子数组

**滑动窗口法：** 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。

**leetcode题号**：209，904，76

**leetcode 209:**
滑动窗口用一个for循环代替暴力搜索的两个for循环。这一个for循环是对窗口终止位置。**将O(n^2)暴力解法降为O(n)。**

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

**leetcode 904:**
滑动窗口，对右边界for循环，实时维护一个哈希表（字典），通过字典中key的数目判断窗口是否符合要求。

**leetcode 76:**
**我的做法：** 符合条件的s的字串的首尾必然是在t内，所以只需要对s内被t包含的元素滑动窗口。dic始终记录着当前滑动窗口下，我们还需要的元素数量。
缺点：判断当前窗口下是否符合要求，如果每次判断滑动窗口是否包含了T的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费O(k)的时间复杂度，k代表字典长度。

**题解做法：** 维护一个额外的变量needCnt来记录所需元素的总数量，当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时needCnt也要减少1，这样我们通过needCnt就可以知道是否满足条件，而无需遍历字典了。

有空可以尝试把二者结合

## 6.螺旋矩阵II
**leetcode题号**：59，54，剑指Offer 29
**leetcode 59:**
本题并不涉及到什么算法，就是模拟过程，但却十分考察对代码的掌控能力。
坚持循环不变量原则,由外向内一圈一圈这么画下去,这里一圈下来。我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。
**leetcode 54:**
**方法1：** 和 59 类似，区别是这里不是正方形，所以要区分一下横纵坐标。有一个变量count记录取到的元素个数，实时判断是否取完所有元素。
**方法2：** 算出完整的循环数，然后判断是否有剩余的不完整循环，即残存一行或者一列，有则添加，无则直接返回。

## 7.总结：
一共讲解了四道经典数组题目，每一道题目都代表一个类型，一种思想。
* 二分法
* 双指针
* 滑动窗口
* 模拟行为
   感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实真正解决题目的代码都是简洁的，或者有原则性的。

